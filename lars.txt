Logic Analyzer in Rust

Entry: la.rs
Date: Sat Jan 31 11:40:42 EST 2015

So the basic ideas:

- Think of Rust as the implementation + scripting language
- Keep integration in sigrok in mind


This is a built off of the ideas of pyla, a Python + C++ logic
analyzer.  It worked fine, but still was clumsy in its aproach so I
started thinkig that Rust might be good as both a core implementation
language for the signal processors and the dataflow glue.


Entry: Synchronicity
Date: Sat Jan 31 11:43:28 EST 2015

Meaning: is it really necessary to process events from multiple
sources at the same time?  This is about the only obviou reason to
_not_ use a task/process abstraction for handling communication
protocols.


Entry: Threads
Date: Sat Jan 31 23:51:03 EST 2015

Solve the rest of the dataflow programming using concurrent
programming?  It seems the most natural approach.  A good trade-off
between speed and ease of use:

- front-end: processes a lot of data but produces likely very little.
  a synchronous state machine seems best here.

- back-end: processes little data but might need more elaborate
  code/data structure to do its job: higher abstraction seems best
  here.

The question is about task switch granularity.  For 20MHz data rate
there is no way that this can be anything other than a tight
single-task loop over a data array.

It would be nice though to abstract the connectivity.  I.e. if I want
to chain two processors, it will figure out how they pass data.

[1] http://doc.rust-lang.org/std/thread/
